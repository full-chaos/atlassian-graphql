// Code generated by go/tools/generate_jira_project_models/main.go. DO NOT EDIT.
package gen

import (
	"encoding/json"
	"errors"
	"fmt"
	"strings"
)

const (
	PageInfoHasEndCursor   = true
	ProjectsEdgeHasCursor  = true
	OpsgenieEdgeHasCursor  = true
	ProjectHasID           = true
	RefetchStrategy        = "node"
)

const JiraProjectsPageQueryTemplate = `query JiraProjectsPage(
  $cloudId: ID!,
  $first: Int!,
  $after: String,
  $opsFirst: Int!
) {
  jira {
    projects: allJiraProjects(
      cloudId: $cloudId,
      filter: { types: [__PROJECT_TYPES__] },
      first: $first,
      after: $after
    ) {
      pageInfo { hasNextPage endCursor }
      edges {
        cursor
        node {
          id
          key
          name
          opsgenieTeams: opsgenieTeamsAvailableToLinkWith(first: $opsFirst) {
            pageInfo { hasNextPage endCursor }
            edges {
              cursor
              node {
                id
                name
              }
            }
          }
        }
      }
    }
  }
}
`

const JiraProjectOpsgenieTeamsPageQuery = `query JiraProjectOpsgenieTeamsPage(
  $projectId: ID!,
  $first: Int!,
  $after: String
) {
  project: node(id: $projectId) {
    ... on JiraProject {
      opsgenieTeams: opsgenieTeamsAvailableToLinkWith(first: $first, after: $after) {
        pageInfo { hasNextPage endCursor }
        edges {
          cursor
          node {
            id
            name
          }
        }
      }
    }
  }
}
`

func BuildJiraProjectsPageQuery(projectTypes []string) (string, error) {
	if len(projectTypes) == 0 {
		return "", errors.New("projectTypes must be non-empty")
	}
	clean := make([]string, 0, len(projectTypes))
	for _, raw := range projectTypes {
		v := strings.ToUpper(strings.TrimSpace(raw))
		if v == "" {
			return "", errors.New("empty project type")
		}
		for i, r := range v {
			if r == '_' {
				continue
			}
			if i == 0 {
				if r < 'A' || r > 'Z' {
					return "", fmt.Errorf("invalid project type %q", raw)
				}
				continue
			}
			if (r < 'A' || r > 'Z') && (r < '0' || r > '9') {
				return "", fmt.Errorf("invalid project type %q", raw)
			}
		}
		clean = append(clean, v)
	}
	return strings.ReplaceAll(
		JiraProjectsPageQueryTemplate,
		"__PROJECT_TYPES__",
		strings.Join(clean, ", "),
	), nil
}

type PageInfo struct {
	HasNextPage bool    `json:"hasNextPage"`
	EndCursor   *string `json:"endCursor,omitempty"`
}

type OpsgenieTeamNode struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type OpsgenieTeamEdge struct {
	Cursor *string         `json:"cursor,omitempty"`
	Node   OpsgenieTeamNode `json:"node"`
}

type OpsgenieTeamsConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []OpsgenieTeamEdge `json:"edges"`
}

type JiraProjectNode struct {
	ID           *string               `json:"id,omitempty"`
	Key          string                `json:"key"`
	Name         string                `json:"name"`
	OpsgenieTeams OpsgenieTeamsConnection `json:"opsgenieTeams"`
}

type JiraProjectEdge struct {
	Cursor *string        `json:"cursor,omitempty"`
	Node   JiraProjectNode `json:"node"`
}

type JiraProjectsConnection struct {
	PageInfo PageInfo          `json:"pageInfo"`
	Edges    []JiraProjectEdge `json:"edges"`
}

type JiraProjectsPageData struct {
	Jira struct {
		Projects JiraProjectsConnection `json:"projects"`
	} `json:"jira"`
}

type ProjectOpsgenieTeamsByNodeData struct {
	Project *struct {
		OpsgenieTeams OpsgenieTeamsConnection `json:"opsgenieTeams"`
	} `json:"project"`
}

type ProjectOpsgenieTeamsByJiraData struct {
	Jira struct {
		Project *struct {
			OpsgenieTeams OpsgenieTeamsConnection `json:"opsgenieTeams"`
		} `json:"project"`
	} `json:"jira"`
}

func DecodeJiraProjectsPage(data map[string]any) (*JiraProjectsPageData, error) {
	b, err := json.Marshal(data)
	if err != nil {
		return nil, err
	}
	var out JiraProjectsPageData
	if err := json.Unmarshal(b, &out); err != nil {
		return nil, err
	}
	return &out, nil
}

func DecodeProjectOpsgenieTeams(data map[string]any) (*OpsgenieTeamsConnection, error) {
	b, err := json.Marshal(data)
	if err != nil {
		return nil, err
	}

	if RefetchStrategy == "node" {
		var out ProjectOpsgenieTeamsByNodeData
		if err := json.Unmarshal(b, &out); err != nil {
			return nil, err
		}
		if out.Project == nil {
			return nil, errors.New("missing project")
		}
		teams := out.Project.OpsgenieTeams
		return &teams, nil
	}

	var out ProjectOpsgenieTeamsByJiraData
	if err := json.Unmarshal(b, &out); err != nil {
		return nil, err
	}
	if out.Jira.Project == nil {
		return nil, errors.New("missing jira.project")
	}
	teams := out.Jira.Project.OpsgenieTeams
	return &teams, nil
}

